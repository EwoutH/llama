# Local lineage report

```python, name="import dependencies", echo=False
import matplotlib.pyplot as pyplot
import pandas as pd 
import os
import data_parsing as dp
import make_tree_figures as tree_viz
import matplotlib.font_manager as font_manager
import matplotlib as mpl
from collections import defaultdict
import tabulate
import datetime as dt
import csv
import numpy as np
import scipy as sp

import warnings
warnings.filterwarnings("ignore")

filtered_db_metadata = "" ##CHANGE
input_csv = "" ##CHANGE
full_metadata_file = "" ##CHANGE


QC_fail_file = "" ##CHANGE
missing_seq_file = "" ##CHANGE

input_directory = "" ##CHANGE
output_directory = "" ##CHANGE
name_stem_input = "" ##CHANGE

if "/" in name_stem_input:
    name_stem = name_stem_input.split("/")[-1]
else:
    name_stem = name_stem_input

summary_dir = "" ##CHANGE
figdir = "" ##CHANGE
tree_dir = "" ##CHANGE

input_name_column = "" ##CHANGE
database_name_column = "" ##CHANGE


colour_fields_input = "" ##CHANGE
label_fields_input = "" ##CHANGE

colour_fields = []
if colour_fields_input != "NONE":
    options = colour_fields_input.split(",")
    for i in options: 
        colour_fields.append(i)

label_fields= []
if label_fields_input != "NONE":
    options = label_fields_input.split(",")
    for i in options: 
        label_fields.append(i)

font_props = font_manager.FontProperties(family=["sans-serif"])
a = matplotlib.font_manager.FontManager()
a.findfont(font_props, fallback_to_default=True)

pyplot.rcParams.update({'figure.max_open_warning': 0})

mpl.rcParams['font.weight']=50
mpl.rcParams['axes.labelweight']=50

```


```python, name="parse metadata", echo=False, results='raw'

present_in_tree, tip_to_tree = dp.parse_tree_tips(tree_dir)

query_dict, tree_to_tip = dp.parse_filtered_metadata(filtered_db_metadata, tip_to_tree) #Just the lines with their queries plus the closest match in db

if input_csv != '':
    query_dict = dp.parse_input_csv(input_csv, query_dict, input_name_column, colour_fields, label_fields) #Any query information they have provided

full_tax_dict = dp.parse_full_metadata(query_dict, full_metadata_file, tip_to_tree, present_in_tree, database_name_column)
```

```python, name="QC fails", echo=False, results="raw"
count_fails = 0
count_missing = 0

with open(missing_seq_file) as f:
    for l in f:
        if "name" not in l:
            count_missing += 1

if QC_fail_file != "": 
    with open(QC_fail_file) as f:
        next(f)
        for l in f:
            count_fails += 1

if count_fails != 0 or count_missing != 0:
    if count_fails != 0:
        fail_dict = dp.investigate_QC_fails(QC_fail_file)
        if len(fail_dict) > 0:
            print("The following sequences have failed QC:\n")
            for seq, reason in fail_dict.items():
                pretty_name = seq.replace("'","")
                pretty_reason = reason.replace("'","")
                print(" - " + pretty_name, pretty_reason)
    if count_missing != 0:
        print("\n")
        failed_names = dp.print_missing_seqs(missing_seq_file)
        print("The following seqs were not found in db and a fasta file was not provided, so LLAMA was unable to add them into phylogenies:\n")
        for i in failed_names:
            print(" - " + i.replace("'","")) 
```

```python, name="early descriptions", echo=False, results='tex'
number_seqs = len(query_dict)

db_number = 0
not_in_db_number = 0
for tax in query_dict.values():
    if tax.in_db:
        db_number += 1
    else:
        not_in_db_number += 1

print(str(number_seqs) + " sequences were provided in total.")

if db_number != 0 and not_in_db_number != 0:
    print(str(db_number) + " were found in the database, leaving " + str(not_in_db_number) + " which were not.")
elif db_number == 0:
    print("None of the sequences were found in the database.")
elif not_in_db_number == 0:
    print("All of the sequences were found in the database.")

```

The table below is a summary of these sequences provided with metadata, along with the global lineage they have been assigned.
To get more information about individual lineages, click on the lineage name in the table. 

```python, name="first_table", echo=False, results="tex"

df = dp.make_initial_table(query_dict, colour_fields, label_fields)

print(df.to_markdown())
```

## Phylogenies

The nearest neighbours of each of the query sequences are shown below to enable the assessment of monophyly.
Underneath each tree is a bar chart summarising the lineages present.


```python, name="make_trees", echo=False, include=False, figure=False
too_tall_trees, overall_tree_number, overall_df_dict, colour_dict_dict = tree_viz.make_all_of_the_trees(tree_dir, full_tax_dict, query_dict, colour_fields, label_fields)
``` 

```python, name="make_legend", echo=False, include=False, results='tex'
for trait, colour_dict in colour_dict_dict.items():
    tree_viz.make_legend(colour_dict)
    number_of_options = len(colour_dict)
    if number_of_options > 15:
        print("WARNING: There are more than 15 options to colour by for " + trait + ", which will make it difficult to see the differences between colours. Consider adding the trait to the taxon labels on the tree by using the flag _--label-fields_ when calling CIVET.")
```
```python,name="show_legend",echo=False,results='raw'
for i, trait in enumerate(colour_dict_dict.keys()):
    print("The legend for " + trait + " is shown below.\n")
    print("![](" + figdir + "/" + name_stem + "_make_legend_" + str(i+1) + ".png)")
    print("\n")
```

```python, name="make_lineage_bars", echo=False, include=False, figure=False
tree_to_lin_fig, lineages_present = tree_viz.describe_lineages(full_tax_dict)
```

```python, name="show_trees", echo=False, results='raw'

    for i in range(1,overall_tree_number+1):
        tree_name = "Tree " + str(i)
        lookup = "local_" + str(i)
        print("## " + tree_name)
        if len(tree_to_tip[lookup]) == 1:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " query.")
        else:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " queries.")
        print("   ")
        print("![](" + figdir + "/" + name_stem + "_make_trees_" + str(i) + ".png)")

        print("#### Lineage summary")
        if len(lineages_present[lookup]) > 2:
            print("![](" + figdir + "/" + name_stem + "_make_lineage_bars_" + str(tree_to_lin_fig[lookup]) + ".png)")
        else:
            lins = lineages_present[lookup]
            for i,v in lins.items():
                print(" - " + str(i) + " (" + str(v) + " sequences)") 

```

```python, name="Tree error checking", echo=False, results='raw'
if too_tall_trees != []:
    for tree in too_tall_trees:
        print("Tree" + str(tree) + " is too large to be rendered here.")
```



### Software versions

This report was made using:

```python, name='software versions', echo=False, results='raw'

import platform


print("Python " + platform.python_version())

print("Matplotlib version " + matplotlib.__version__)
print("Pandas version " + pd.__version__)
print("Tabulate version " + tabulate.__version__)
print("CSV version " + csv.__version__)
print("Numpy version " + np.__version__)
print("Scipy version " + sp.__version__)
print("Baltic")


print("llama version is 0.1")
```

### Acknowledgements

This report was generated by llama.

Tree data was visualised using [baltic](https://github.com/evogytis/baltic)

```python, name="footer", echo=False, results='raw'
print("![](" + figdir + "/footer.png)")
```
