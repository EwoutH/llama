# Local lineage report

```python, name="import dependencies", echo=False
import matplotlib.pyplot as pyplot
import pandas as pd 
import os
import data_parsing as dp
import make_tree_figures as tree_viz
import matplotlib.font_manager as font_manager
import matplotlib as mpl
from collections import defaultdict
import tabulate
import datetime as dt
import csv
import numpy as np
import scipy as sp

import warnings
warnings.filterwarnings("ignore")

filtered_db_metadata = "" ##CHANGE
input_csv = "" ##CHANGE
full_metadata_file = "" ##CHANGE


QC_fail_file = "" ##CHANGE
missing_seq_file = "" ##CHANGE

input_directory = "" ##CHANGE
output_directory = "" ##CHANGE
name_stem_input = "" ##CHANGE

if "/" in name_stem_input:
    name_stem = name_stem_input.split("/")[-1]
else:
    name_stem = name_stem_input

summary_dir = "" ##CHANGE
figdir = "" ##CHANGE
tree_dir = "" ##CHANGE

input_name_column = "" ##CHANGE
database_name_column = "" ##CHANGE

font_props = font_manager.FontProperties(family=["sans-serif"])
a = matplotlib.font_manager.FontManager()
a.findfont(font_props, fallback_to_default=True)

pyplot.rcParams.update({'figure.max_open_warning': 0})

mpl.rcParams['font.weight']=50
mpl.rcParams['axes.labelweight']=50

```


```python, name="parse metadata", echo=False, results='raw'

present_in_tree, tip_to_tree = dp.parse_tree_tips(tree_dir)

query_dict, tree_to_tip = dp.parse_filtered_metadata(filtered_db_metadata, tip_to_tree) #Just the lines with their queries plus the closest match in db

if input_csv != '':
    query_dict = dp.parse_input_csv(input_csv, query_dict, input_name_column) #Any query information they have provided

full_tax_dict = dp.parse_full_metadata(query_dict, full_metadata_file, present_in_tree, database_name_column)
```

```python, name="QC fails", echo=False, results="raw"
count_fails = 0
count_missing = 0

with open(missing_seq_file) as f:
    for l in f:
        if "name" not in l:
            count_missing += 1

if QC_fail_file != "": 
    with open(QC_fail_file) as f:
        next(f)
        for l in f:
            count_fails += 1

if count_fails != 0 or count_missing != 0:
    if count_fails != 0:
        fail_dict = dp.investigate_QC_fails(QC_fail_file)
        if len(fail_dict) > 0:
            print("The following sequences have failed QC:\n")
            for seq, reason in fail_dict.items():
                pretty_name = seq.replace("'","")
                pretty_reason = reason.replace("'","")
                print(" - " + pretty_name, pretty_reason)
    if count_missing != 0:
        print("\n")
        failed_names = dp.print_missing_seqs(missing_seq_file)
        print("The following seqs were not found in db and a fasta file was not provided, so LLAMA was unable to add them into phylogenies:\n")
        for i in failed_names:
            print(" - " + i.replace("'","")) 
```

```python, name="early descriptions", echo=False, results='tex'
number_seqs = len(query_dict)

db_number = 0
not_in_db_number = 0
for tax in query_dict.values():
    if tax.in_db:
        db_number += 1
    else:
        not_in_db_number += 1

print(str(number_seqs) + " sequences were provided in total.")

if db_number != 0 and not_in_db_number != 0:
    print(str(db_number) + " were found in the database, leaving " + str(not_in_db_number) + " which were not.")
elif db_number == 0:
    print("None of the sequences were found in the database.")
elif not_in_db_number == 0:
    print("All of the sequences were found in the database.")

```

The table below is a summary of these sequences provided with metadata, along with the global lineage they have been assigned.
To get more information about individual lineages, click on the lineage name in the table. 

```python, name="first_table", echo=False, results="tex"

df = dp.make_initial_table(query_dict)

print(df.to_markdown())
```

## Phylogenies

The nearest neighbours of each of the query sequences are shown below to enable the assessment of monophyly.


```python, name="make_trees", echo=False, include=False, figure=False
too_tall_trees, overall_tree_number, overall_df_dict = tree_viz.make_all_of_the_trees(tree_dir, full_tax_dict, query_dict)
``` 

```python, name="show_trees", echo=False, results='raw'

    for i in range(1,overall_tree_number+1):
        tree_name = "Tree " + str(i)
        lookup = "local_" + str(i)
        if len(tree_to_tip[lookup]) == 1:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " query.")
        else:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " queries.")
        print("   ")
        print("![](" + figdir + "/" + name_stem + "_make_trees_" + str(i) + ".png)")

```

```python, name="Tree error checking", echo=False, results='raw'
if too_tall_trees != []:
    for tree in too_tall_trees:
        print("Tree" + str(tree) + " is too large to be rendered here.")
```

## Tree background

The following plots describe the location of the sequences in the collapsed nodes.
If more than one country was present, the bar chart describes the number of sequences present in each country. 
Where there were 10 countries or more, the largest 10 have been taken. 

```python, name="tree_background", echo=False, include=False, fig=False
bar_count, bar_to_tree = tree_viz.describe_tree_background(full_tax_dict, tree_dir, overall_df_dict)
```

```python, name="display bar charts", echo=False, results='raw'
for i in range(1,bar_count+1):
    #tree_name = bar_to_tree[i]
    #right_rows = df["Tree"]==tree_name
    #relevant_df = df[right_rows].drop(columns=["Tree"])
    #print(relevant_df.to_markdown())
    #print("   ")

    print("![](" + figdir + "/" + name_stem + "_tree_background_" + str(i) + ".png)")
```



### Software versions

This report was made using:

```python, name='software versions', echo=False, results='raw'

import platform


print("Python " + platform.python_version())

print("Matplotlib version " + matplotlib.__version__)
print("Pandas version " + pd.__version__)
print("Tabulate version " + tabulate.__version__)
print("CSV version " + csv.__version__)
print("Numpy version " + np.__version__)
print("Scipy version " + sp.__version__)
print("Baltic")


print("llama version is 0.1")
```

### Acknowledgements

This report was generated by llama.

Tree data was visualised using [baltic](https://github.com/evogytis/baltic)

```python, name="footer", echo=False, results='raw'
print("![](" + figdir + "/footer.png)")
```
